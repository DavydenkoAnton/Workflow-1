Теоретическое задание

Составить кроссворд (например, с помощью excel) с терминами (имена существительные в именительном падеже). На одном листе изобразить заполненный кроссворд (с ответами), на другом – пустые клетки кроссворда и задания к ним. Использовать не менее 15 слов. Лист с незаполненной формой кроссворда и заданиями распечатать.

Практические задания.

1. Создать класс «строка» (аналогичный string из стандартной библиотеки шаблонов).
1.1. Класс «строка» должен иметь конструктор по умолчанию, конструктор копирования, конструктор из Си-строки (const char*), конструктор перемещения.
1.2. Перегрузить оператор вывода в поток <<
1.3. Класс строка должен иметь перегруженный оператор =
1.4. Класс строка должен иметь перегруженные операторы сравнения == < > <= >= !=
1.5. Класс строка должен иметь перегруженные операторы += и +.
1.6. Допустить сложение Си-строк и строк разрабатываемого класса
1.7. Перегрузить оператор ввода из потока >>
1.8. Реализовать преобразование строки к числам int и double и наоборот

2. Создать шаблон класса «ассоциативный массив» (аналогичный map из стандартной библиотеки шаблонов), на основе структуры данных «двоичное дерево» (материал последнего занятия). Параметры шаблона должны задавать тип данных для ключа и значения
2.1. Реализовать конструктор, деструктор, оператор индексирования
2.2. Реализовать метод, выводящий все элементы дерева в порядке возрастания ключа в поток
2.3. Реализовать итератор для дерева (например, используя двухсвязный список)
2.3.1 Реализовать методы у класса дерева, возвращающие итераторы
2.3.1.1 begin() указывающий на первый существующий элемент (с минимальным значением ключа).
2.3.1.2 end() указывающий на элемент после последнего (первый несуществующий). Другими словами – недействительный итератор.
2.3.2. Реализовать операцию разыменования итератора, возвращающую ссылку на значение элемента.
2.3.3. Реализовать операции инкремента и декремента итератора
2.3.4. Реализовать операцию сравнения итераторов ==
2.4. Реализовать метод поиска элемента по ключу, возвращающий итератор, указывающий на найденный элемент. Если элемент не найден – вернуть недействительный итератор.
2.5. Реализовать метод поиска элемента по значению, возвращающий итератор, указывающий на первый найденный элемент. Если элемент не найден – вернуть недействительный итератор.
2.6. Реализовать метод удаления элемента дерева, указываемых итератором.
2.7. Придумать схему поиска всех совпадающих по значению элементов дерева.
2.8. Реализовать метод слияния двух однотипных деревьев.
